{"version":3,"sources":["img/about.png","components/Node/Node.js","containers/Visualizer/algorithms/dijkstra.js","containers/Visualizer/algorithms/astar.js","containers/Visualizer/algorithms/breathFirst.js","containers/Visualizer/algorithms/depthFirst.js","containers/Visualizer/algorithms/greedyBFS.js","containers/Visualizer/mazeGenerator/gridDivisionMazeGenerator.js","containers/Visualizer/mazeGenerator/randomWalls.js","components/About/Backdrop.js","components/About/About.js","containers/Visualizer/Visualizer.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","this","props","col","row","clicked","isStartNode","isEndNode","isWall","isVisited","isShortest","mouseEnter","animation","isStartNodeSelected","isEndNodeSelected","classe","animationStyle","animationDelay","delay","className","onMouseEnter","onMouseDown","style","React","Component","findPathWithDijkstra","nodes","startNode","endNode","allowDiagonals","allNodesVisitedByOrder","distance","i","length","j","Infinity","pq","PriorityQueue","enqueue","currentNode","dequeue","push","getNeighboursNodes","forEach","neighbourNode","weight","prevRow","prevCol","isEmpty","shift","pop","visitedNodes","allNodes","neighbours","lastRow","collection","element","added","splice","findPathWithAStar","loopNode","f","g","h","closed","heuristic","gCost","beenVisited","neigh","reorder","eleIndex","indexOf","leftIndex","leftElement","node","goal","Math","abs","findPathWithBreathFirst","findPathWithDepthFirst","S","Stack","findPathWithGreedyBFS","choose_orientation","width","height","random","randomNumber","min","max","round","generateRandomWalls","grid","nodeObj","nodesClone","cloneNodes","Backdrop","show","onClick","About","toggle","startNodeRow","floor","window","innerHeight","startNodeCol","innerWidth","endNodeRow","endNodeCol","Visualizer","nodeClicked","state","isRunning","isMousePressed","setState","startNodeSelected","endNodeSelected","getNewGridWithWalls","prevState","isVisualized","restructureVisualizer","isStartSelected","isEndSelected","startAlgo","e","addAnimation","type","keyCode","target","blur","resetNodes","setTimeout","result","currentAlgo","allowDiagonal","startVisualizer","visited","animateDelay","algoSpeed","timeoutForShortestPath","Number","visitedNodesTimeout","backTrack","lastStep","animationCounter","animationIncrement","currentNodeRow","currentNodeCol","stepBackNode","unshift","shortestnodeTimeoutDelay","shortestnodeTimeout","nodeWitoutDelay","removeAniDelayFromNodes","clearTimeout","slice","resetVisualizer","generateMaze","resetWalls","resetPath","algoSetup","value","speedChangeHandler","diagonalChangeHandler","mazeChangeHandler","nodesGrid","randomWalls","wx","wy","hx","hy","box1","box2","box","x","y","maxX","maxY","orientation","currentBox","changed","gridDivisionMazeGenerator","toggleAbout","console","log","showAbout","undefined","document","addEventListener","column","totalRows","totalCols","htmlFor","name","id","onChange","disabled","checked","src","img","alt","map","colum","class","key","rowClone","nodesStateClone","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.337949da.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABmJLR0QA/wD/AP+gvaeTAAADrklEQVRoge1Yu24TURA9u961TRJSRTyUBJGkAyEKviBtkPgBUgckCiQKCmo6eiAl34AQEiLkDxCichOFEEs8LCQSLCVxsncovF7f9x2v8yjiKRLffcycM+fMXa+BUYxiFKMYxXmOSD9w59POXYBWAUwTAQCBCAABxrr7B71/oPwc8muJ8uMA5Sf6ubR1nsSsUeRtCopWtpavvpfxJiYneg3CtAmIpIQ6ABkoj3SJvDMRxCqAa14CRJjxAnIBcHdOAcQiLd+r1pzV8ZoKhLpexi5DktbzhhQIyMryK+jwAKKz3z2Y1BCltYFtaCPNIMD3q9Gd/Fy818az2xexNH8FAPBu4y+ef9kBVScYXQ/U5Chg7Y5TVhWQOOpgea6O+zemipzLN6ewudvBm80OUEmZee2qhwmIwe2iAMgyzE/WjUILk1VQ1kYUp/wZsdXQIjaOkARGllO2VndQ+mshraME6822kXbtexsUJ4VFe7PmXQv9M2uIh9zT4wrWfh/gwYctLF2fAAC83fiH9V8ZUKsVgNS8qiI+pRkE+HaRP8uk4+oFrP3J8PHHLoiAKE2Bag0QA9rFtjNxCHCGyb5rSKSjClCtF+AGy+tWnUHA1RFf51RAtNdGdrivAIjTOlAd95N21dRqeAnoezrngaMDyA72sPXwlpJ29uVXxOlYybxq84IKlNreAtvdIHm958IEHH61Senyss2sNpLeobXPSJhA6QdZn6RVAWlP59jQNQdhAowhNQBonbMNm3Itq4ajZoiAtzuB4Sq+MTpmQPW3+0HmnZEQAbIC1TunE7V3Ts8LEcrbR+myGpOAxy6u7sikhdkpIiBiDGlIdQYB2ZclH2QOBUgHGrKLRXUGAfuNvM4BJN2rJg6Dc86eVsNLoEhcojvK2kib3+izi1FfzzvIDOj2cNjF2TlLXnjz+mr0SYcJCMbT0DcjAKK0jksvPquypzXJ+3y7HNODLOBXfUaqY4jyL26QAJnqBmbNogiDgL3r4c7ZFXGSVrZKT029RogACE0izHDAhaxWlrQ9L4GAbR2u8VIvIlohoqYsufnibTknpLUIXOtYK6R7a1GQ3I4iWtHxGr9Oc+Pyq29k76LS9UacRIutR3M/y9YJheXXaV4w/NqonDB4YCgCFr/2FWlUOvFi6/HJggeGIOAZ0i74pycPHhjSQsaeDjSSUwQPHIeFet4/A/DAMATUl5NGcnT64AHbj7vM6O3h4gzBA0MoEBHWMtB4ltC91pOF1nGCOlfxH63nT4avT9MSAAAAAElFTkSuQmCC\"","import React from 'react';\r\n\r\n\r\n\r\nclass Node extends React.Component{\r\n\r\n\r\n\r\n    render(){\r\n\r\n        const {\r\n            col,\r\n            row,\r\n            clicked,\r\n            isStartNode,\r\n            isEndNode,\r\n            isWall,\r\n            isVisited,\r\n            isShortest,\r\n            mouseEnter,\r\n            // mouseUp,\r\n            animation,\r\n            isStartNodeSelected,\r\n            isEndNodeSelected\r\n\r\n        }=this.props;\r\n\r\n\r\n        let classe='node';\r\n        if(isStartNode)\r\n            classe+=\" startNode\";\r\n        else if(isEndNode)\r\n            classe+=\" endNode\";\r\n        else if(isWall)\r\n            classe+=\" wallNode\";\r\n\r\n        if(isVisited)\r\n            classe+=\" visited\";\r\n        if(isShortest)\r\n            classe+=\" shortest\";\r\n\r\n        if(!animation)\r\n            classe+=\" noAnimation\";\r\n\r\n        if(isStartNode && isStartNodeSelected)\r\n            classe+=\" noAnimation\";\r\n        if(isEndNode && isEndNodeSelected)\r\n            classe+=\" noAnimation\";\r\n\r\n\r\n\r\n        // console.log(this.props.count);\r\n        // if(this.props.count>1)\r\n        //     classe+=\" remove\";\r\n\r\n\r\n        let animationStyle={};\r\n        // if(this.props.delay<=0)\r\n        //     animationStyle.animation='none';\r\n        // else{\r\n            // animationStyle.animation=\"animateVisitedNodes 0.05s forwards ease-out\";\r\n            animationStyle.animationDelay=this.props.delay+'s';\r\n\r\n        // }\r\n\r\n\r\n\r\n        return(\r\n            <div\r\n                className={classe}\r\n                // onClick={()=>clicked(row,col)}\r\n                onMouseEnter={()=>mouseEnter(row,col)}\r\n                // onMouseUp={mouseUp}\r\n                onMouseDown={()=>clicked(row,col)}\r\n                style={animationStyle}\r\n                // style={{border:10}}\r\n                />\r\n        )\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\nexport default Node;","//Took inspiration from:\r\n//https://medium.com/@adriennetjohnson/a-walkthrough-of-dijkstras-algorithm-in-javascript-e94b74192026\r\n//https://www.tutorialspoint.com/Dijkstra-s-algorithm-in-Javascript#:~:text=Dijkstra's%20algorithm%20is%20an%20algorithm,edges%20when%20creating%20a%20graph.\r\n\r\nexport const findPathWithDijkstra = (nodes,startNode, endNode,allowDiagonals)=>{\r\n\r\n    let allNodesVisitedByOrder=[];\r\n\r\n\r\n\r\n    startNode.distance=0;\r\n\r\n\r\n    // nodes = updatedNodes(nodes);\r\n\r\n\r\n    for(let i=0;i<nodes.length;i++){\r\n        for(let j=0;j<nodes[i].length;j++){\r\n            if(startNode!==nodes[i][j]){\r\n                nodes[i][j].isVisited=false;\r\n                nodes[i][j].distance = Infinity;\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    let neighboursList;\r\n    let pq = new PriorityQueue();\r\n\r\n    pq.enqueue(startNode);\r\n\r\n    while (!pq.isEmpty()){\r\n\r\n        let currentNode = pq.dequeue();\r\n        currentNode.isVisited = true;\r\n\r\n        if(currentNode.isWall){\r\n            continue;\r\n        }\r\n\r\n        allNodesVisitedByOrder.push(currentNode);\r\n\r\n        neighboursList=getNeighboursNodes(currentNode,nodes,allowDiagonals);\r\n        neighboursList.forEach(neighbourNode=>{\r\n\r\n            let weight = currentNode.distance + neighbourNode.weight;\r\n\r\n            if(weight < neighbourNode.distance){\r\n                nodes[neighbourNode.row][neighbourNode.col].distance=weight;\r\n                // backTrack[neighbourNode['node']]=currentNode[0];\r\n                nodes[neighbourNode.row][neighbourNode.col].prevRow=currentNode.row;\r\n                nodes[neighbourNode.row][neighbourNode.col].prevCol=currentNode.col;\r\n                pq.enqueue(nodes[neighbourNode.row][neighbourNode.col]);\r\n            }\r\n\r\n        });\r\n\r\n        if(currentNode.row === endNode.row && currentNode.col === endNode.col ){\r\n            // console.log('breaking');\r\n            break;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    allNodesVisitedByOrder.shift();\r\n    allNodesVisitedByOrder.pop();\r\n\r\n    return {\r\n        visitedNodes:allNodesVisitedByOrder,\r\n        allNodes:nodes\r\n    };\r\n\r\n};\r\n\r\n//\r\n// const updatedNodes=(nodes)=>{\r\n//\r\n//     let allNodes=[...nodes];\r\n//\r\n//     for(let i=0;i<allNodes.length;i++){\r\n//\r\n//         for(let j=0;j<allNodes[i].length;j++){\r\n//             // allNodes.push(nodes[i][j]);\r\n//             allNodes[i][j].isVisited=false;\r\n//             allNodes[i][j].distance = Infinity;\r\n//         }\r\n//     }\r\n//\r\n//\r\n//     return allNodes;\r\n// };\r\n\r\n\r\nconst getNeighboursNodes = (currentNode,nodes,allowDiagonals)=>{\r\n\r\n\r\n    let neighbours=[];\r\n\r\n    let lastRow=nodes[nodes.length-1];\r\n\r\n    //upper node\r\n    if(currentNode.row>0) {\r\n        neighbours.push(nodes[currentNode.row-1][currentNode.col]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n\r\n    }\r\n    //left node\r\n    if(currentNode.col>0){\r\n        neighbours.push(nodes[currentNode.row][currentNode.col-1]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n    }\r\n    //right node\r\n    if(currentNode.col < lastRow[lastRow.length-1].col){\r\n        neighbours.push(nodes[currentNode.row][currentNode.col+1]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n    }\r\n    // bottom node\r\n    if(currentNode.row < lastRow[0].row){\r\n        neighbours.push(nodes[currentNode.row+1][currentNode.col]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n    }\r\n\r\n\r\n    if(allowDiagonals){\r\n        // upper left node\r\n        if(currentNode.row>0 && currentNode.col>0){\r\n            neighbours.push(nodes[currentNode.row-1][currentNode.col-1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n        //upper right node\r\n        if(currentNode.row>0 && currentNode.col < lastRow[lastRow.length-1].col){\r\n\r\n            neighbours.push(nodes[currentNode.row-1][currentNode.col+1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n        // bottom left node\r\n        if(currentNode.row < lastRow[0].row && currentNode.col>0){\r\n            neighbours.push(nodes[currentNode.row+1][currentNode.col-1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n        // bottom right node\r\n        if(currentNode.row < lastRow[0].row && currentNode.col < lastRow[lastRow.length-1].col){\r\n            neighbours.push(nodes[currentNode.row+1][currentNode.col+1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n    }\r\n\r\n\r\n    return neighbours;\r\n\r\n\r\n};\r\n\r\n\r\nclass PriorityQueue {\r\n    constructor() {\r\n        this.collection = [];\r\n    }\r\n\r\n    enqueue(element){\r\n        if (this.isEmpty()){\r\n            this.collection.push(element);\r\n        } else {\r\n            let added = false;\r\n            for (let i = 1; i <= this.collection.length; i++){\r\n                if (element.distance < this.collection[i-1].distance){\r\n                    this.collection.splice(i-1, 0, element);\r\n                    added = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!added){\r\n                this.collection.push(element);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    dequeue() {\r\n        return this.collection.shift();\r\n    };\r\n\r\n    isEmpty() {\r\n        return (this.collection.length === 0)\r\n    };\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// class Graph {\r\n//     // constructor() {\r\n//         // this.nodes = [];\r\n//         // this.neighboursList = {}; // list showing all neighbour nodes of a node\r\n//     // }\r\n//\r\n//     //\r\n//     //\r\n//     // addNode(node) {\r\n//     //     this.nodes.push(node);\r\n//     //     this.neighboursList[node] = [];\r\n//     // }\r\n//     //\r\n//     //\r\n//     // addEdge(node1, node2, weight) {\r\n//     //     this.neighboursList[node1].push({node:node2, weight: weight});\r\n//     //     this.neighboursList[node2].push({node:node1, weight: weight});\r\n//     // }\r\n//     //\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//     // findPathWithDijkstra(startNode, endNode){\r\n//     //     let times = {};\r\n//     //     let backtrace = {};\r\n//     //     let pq = new PriorityQueue();\r\n//     //\r\n//     //     times[startNode] = 0;\r\n//     //\r\n//     //     // console.log({...times});\r\n//     //\r\n//     //\r\n//     //     this.nodes.forEach(node => {\r\n//     //         if (node !== startNode) {\r\n//     //             times[node] = Infinity\r\n//     //         }\r\n//     //     });\r\n//     //\r\n//     //     pq.enqueue([startNode, 0]);\r\n//     //\r\n//     //\r\n//     //\r\n//     //     while (!pq.isEmpty()) {\r\n//     //         let shortestStep = pq.dequeue();\r\n//     //         let currentNode = shortestStep[0];\r\n//     //         this.neighboursList[currentNode].forEach(neighbor => {\r\n//     //             let time = times[currentNode] + neighbor.weight;\r\n//     //             if (time < times[neighbor.node]) {\r\n//     //                 times[neighbor.node] = time;\r\n//     //                 backtrace[neighbor.node] = currentNode;\r\n//     //                 pq.enqueue([neighbor.node, time]);\r\n//     //             }\r\n//     //         });\r\n//     //     }\r\n//     //\r\n//     //     console.log({...backtrace});\r\n//     //\r\n//     //\r\n//     //\r\n//     //     let path = [endNode];\r\n//     //     let lastStep = endNode;\r\n//     //\r\n//     //     while(lastStep !== startNode) {\r\n//     //         path.unshift(backtrace[lastStep]);\r\n//     //         lastStep = backtrace[lastStep]\r\n//     //     }\r\n//     //\r\n//     //     return `Path is ${path} and time is ${times[endNode]}`;\r\n//     // }\r\n//\r\n//\r\n// }\r\n","//Took inspiration from:\r\n//https://www.youtube.com/watch?v=-L-WgKMFuhE\r\n//https://github.com/bgrins/javascript-astar/blob/master/astar.js\r\n\r\nexport const findPathWithAStar = (nodes,startNode, endNode,allowDiagonals)=>{\r\n\r\n    let allNodesVisitedByOrder=[];\r\n\r\n    let loopNode;\r\n\r\n    //reset all nodes\r\n    for(let i=0;i<nodes.length;i++){\r\n\r\n        for(let j=0;j<nodes[i].length;j++){\r\n\r\n                loopNode=nodes[i][j];\r\n                loopNode.isVisited=false;\r\n                loopNode.f=0;\r\n                loopNode.g=0;\r\n                loopNode.h=0;\r\n                loopNode.closed=0;\r\n                loopNode.prevRow=null;\r\n                loopNode.prevCol=null;\r\n\r\n                if(!loopNode.isWall)\r\n                    loopNode.weight = 1;\r\n                else\r\n                    loopNode.weight = 0;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    let neighboursList;\r\n    let pq = new PriorityQueue();\r\n\r\n    startNode.h = heuristic(startNode,endNode); //get h cost\r\n\r\n    pq.enqueue(startNode);\r\n\r\n    while (!pq.isEmpty()){\r\n\r\n        let currentNode = pq.dequeue();\r\n\r\n        if(currentNode.row === endNode.row && currentNode.col === endNode.col ){\r\n            // console.log('breaking');\r\n            break;\r\n        }\r\n\r\n\r\n        if(currentNode.isWall){\r\n            continue;\r\n        }\r\n\r\n        currentNode.isVisited = true;\r\n\r\n        allNodesVisitedByOrder.push(currentNode);\r\n\r\n        neighboursList = getNeighboursNodes(currentNode,nodes,allowDiagonals);\r\n\r\n        neighboursList.forEach( neighbourNode =>{\r\n\r\n            if(!(neighbourNode.isWall || neighbourNode.closed)) {\r\n\r\n\r\n                let gCost = currentNode.g + neighbourNode.weight;\r\n\r\n                let beenVisited = neighbourNode.isVisited;\r\n\r\n                if (!beenVisited || gCost < neighbourNode.g) {\r\n\r\n                    let neigh = nodes[neighbourNode.row][neighbourNode.col];\r\n\r\n\r\n                    neigh.isVisited = true;\r\n                    neigh.g = gCost;\r\n                    neigh.h = neighbourNode.h || heuristic(neighbourNode, endNode);\r\n                    neigh.f = neigh.g+neigh.h;\r\n\r\n\r\n                    // backTrack[neighbourNode['node']]=currentNode[0];\r\n                    neigh.prevRow = currentNode.row;\r\n                    neigh.prevCol = currentNode.col;\r\n\r\n                    if (!beenVisited)\r\n                        pq.enqueue(neigh);\r\n                    else\r\n                        pq.reorder(neigh);\r\n\r\n                }\r\n            }\r\n        });\r\n\r\n\r\n    }\r\n\r\n    //remove start node\r\n    allNodesVisitedByOrder.shift();\r\n\r\n    return {\r\n        visitedNodes:allNodesVisitedByOrder,\r\n        allNodes:nodes\r\n    };\r\n\r\n};\r\n\r\n\r\nconst getNeighboursNodes = (currentNode,nodes,allowDiagonals)=>{\r\n\r\n\r\n    let neighbours=[];\r\n\r\n    let lastRow=nodes[nodes.length-1];\r\n\r\n    //upper node\r\n    if(currentNode.row>0) {\r\n        neighbours.push(nodes[currentNode.row-1][currentNode.col]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n\r\n    }\r\n    //left node\r\n    if(currentNode.col>0){\r\n        neighbours.push(nodes[currentNode.row][currentNode.col-1]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n    }\r\n    //right node\r\n    if(currentNode.col < lastRow[lastRow.length-1].col){\r\n        neighbours.push(nodes[currentNode.row][currentNode.col+1]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n    }\r\n    // bottom node\r\n    if(currentNode.row < lastRow[0].row){\r\n        neighbours.push(nodes[currentNode.row+1][currentNode.col]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n    }\r\n\r\n\r\n    if(allowDiagonals){\r\n        // upper left node\r\n        if(currentNode.row>0 && currentNode.col>0){\r\n            neighbours.push(nodes[currentNode.row-1][currentNode.col-1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n        //upper right node\r\n        if(currentNode.row>0 && currentNode.col < lastRow[lastRow.length-1].col){\r\n\r\n            neighbours.push(nodes[currentNode.row-1][currentNode.col+1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n        // bottom left node\r\n        if(currentNode.row < lastRow[0].row && currentNode.col>0){\r\n            neighbours.push(nodes[currentNode.row+1][currentNode.col-1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n        // bottom right node\r\n        if(currentNode.row < lastRow[0].row && currentNode.col < lastRow[lastRow.length-1].col){\r\n            neighbours.push(nodes[currentNode.row+1][currentNode.col+1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n    }\r\n\r\n\r\n    return neighbours;\r\n\r\n\r\n};\r\n\r\n\r\nclass PriorityQueue {\r\n    constructor() {\r\n        this.collection = [];\r\n    }\r\n\r\n    enqueue(element){\r\n        if (this.isEmpty()){\r\n            this.collection.push(element);\r\n        } else {\r\n            let added = false;\r\n            for (let i = 1; i <= this.collection.length; i++){\r\n                if (element.f < this.collection[i-1].f){\r\n                    this.collection.splice(i-1, 0, element);\r\n                    added = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!added){\r\n                this.collection.push(element);\r\n            }\r\n        }\r\n\r\n\r\n    };\r\n\r\n    reorder(element){\r\n\r\n\r\n        let eleIndex=this.collection.indexOf(element);\r\n\r\n        while (eleIndex>0){\r\n            let leftIndex=eleIndex-1;\r\n\r\n            if(eleIndex.f<this.collection[leftIndex].f){\r\n                let leftElement=this.collection[leftIndex];\r\n                this.collection[leftIndex]=element;\r\n                this.collection[eleIndex]=leftElement;\r\n\r\n                eleIndex=leftIndex;\r\n            }else\r\n                break;\r\n        }\r\n\r\n\r\n        // if (this.isEmpty()){\r\n        //     this.collection.push(element);\r\n        // } else {\r\n        //     let added = false;\r\n        //     for (let i = 1; i <= this.collection.length; i++){\r\n        //         if (element.f < this.collection[i-1].f){\r\n        //             this.collection.splice(i-1, 0, element);\r\n        //             added = true;\r\n        //             break;\r\n        //         }\r\n        //     }\r\n        //     if (!added){\r\n        //         this.collection.push(element);\r\n        //     }\r\n        // }\r\n    };\r\n\r\n    dequeue() {\r\n        return this.collection.shift();\r\n    };\r\n\r\n    isEmpty() {\r\n        return (this.collection.length === 0)\r\n    };\r\n}\r\n\r\n\r\nfunction heuristic(node,goal) {\r\n\r\n    // console.log(node.row,goal.x)\r\n    const dx = Math.abs(node.row - goal.row);\r\n    const dy = Math.abs(node.col - goal.col);\r\n\r\n    // console.log(dx,dy);\r\n\r\n    return dx + dy;\r\n}\r\n\r\n\r\n\r\n","//Took inspiration from:\r\n//https://en.wikipedia.org/wiki/Breadth-first_search\r\n\r\nexport const findPathWithBreathFirst = (nodes,startNode, endNode,allowDiagonals)=>{\r\n\r\n    let allNodesVisitedByOrder=[];\r\n\r\n\r\n\r\n\r\n    for(let i=0;i<nodes.length;i++){\r\n        for(let j=0;j<nodes[i].length;j++){\r\n            if(startNode!==nodes[i][j]){\r\n                nodes[i][j].isVisited=false;\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    let neighboursList;\r\n    let pq = new PriorityQueue();\r\n\r\n    pq.enqueue(startNode);\r\n\r\n    while (!pq.isEmpty()){\r\n\r\n        let currentNode = pq.dequeue();\r\n        currentNode.isVisited = true;\r\n\r\n        if(currentNode.isWall){\r\n            continue;\r\n        }\r\n\r\n        allNodesVisitedByOrder.push(currentNode);\r\n\r\n        neighboursList=getNeighboursNodes(currentNode,nodes,allowDiagonals);\r\n\r\n        neighboursList.forEach(neighbourNode=>{\r\n\r\n\r\n            if(!neighbourNode.isVisited){\r\n\r\n                neighbourNode.isVisited=true;\r\n                // backTrack[neighbourNode['node']]=currentNode[0];\r\n                nodes[neighbourNode.row][neighbourNode.col].prevRow=currentNode.row;\r\n                nodes[neighbourNode.row][neighbourNode.col].prevCol=currentNode.col;\r\n                pq.enqueue(nodes[neighbourNode.row][neighbourNode.col]);\r\n            }\r\n        });\r\n\r\n        if(currentNode.row === endNode.row && currentNode.col === endNode.col ){\r\n            // console.log('breaking');\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    allNodesVisitedByOrder.shift();\r\n    allNodesVisitedByOrder.pop();\r\n\r\n    return {\r\n        visitedNodes:allNodesVisitedByOrder,\r\n        allNodes:nodes\r\n    };\r\n\r\n};\r\n\r\n//\r\n// const updatedNodes=(nodes)=>{\r\n//\r\n//     let allNodes=[...nodes];\r\n//\r\n//     for(let i=0;i<allNodes.length;i++){\r\n//\r\n//         for(let j=0;j<allNodes[i].length;j++){\r\n//             // allNodes.push(nodes[i][j]);\r\n//             allNodes[i][j].isVisited=false;\r\n//             allNodes[i][j].distance = Infinity;\r\n//         }\r\n//     }\r\n//\r\n//\r\n//     return allNodes;\r\n// };\r\n\r\n\r\nconst getNeighboursNodes = (currentNode,nodes,allowDiagonals)=>{\r\n\r\n\r\n    let neighbours=[];\r\n\r\n    let lastRow=nodes[nodes.length-1];\r\n\r\n    //upper node\r\n    if(currentNode.row>0) {\r\n        neighbours.push(nodes[currentNode.row-1][currentNode.col]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n\r\n    }\r\n    //left node\r\n    if(currentNode.col>0){\r\n        neighbours.push(nodes[currentNode.row][currentNode.col-1]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n    }\r\n    //right node\r\n    if(currentNode.col < lastRow[lastRow.length-1].col){\r\n        neighbours.push(nodes[currentNode.row][currentNode.col+1]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n    }\r\n    // bottom node\r\n    if(currentNode.row < lastRow[0].row){\r\n        neighbours.push(nodes[currentNode.row+1][currentNode.col]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n    }\r\n\r\n\r\n    if(allowDiagonals){\r\n        // upper left node\r\n        if(currentNode.row>0 && currentNode.col>0){\r\n            neighbours.push(nodes[currentNode.row-1][currentNode.col-1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n        //upper right node\r\n        if(currentNode.row>0 && currentNode.col < lastRow[lastRow.length-1].col){\r\n\r\n            neighbours.push(nodes[currentNode.row-1][currentNode.col+1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n        // bottom left node\r\n        if(currentNode.row < lastRow[0].row && currentNode.col>0){\r\n            neighbours.push(nodes[currentNode.row+1][currentNode.col-1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n        // bottom right node\r\n        if(currentNode.row < lastRow[0].row && currentNode.col < lastRow[lastRow.length-1].col){\r\n            neighbours.push(nodes[currentNode.row+1][currentNode.col+1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n    }\r\n\r\n\r\n    return neighbours;\r\n\r\n\r\n};\r\n\r\n\r\nclass PriorityQueue {\r\n    constructor() {\r\n        this.collection = [];\r\n    }\r\n\r\n    enqueue(element){\r\n        if (this.isEmpty()){\r\n            this.collection.push(element);\r\n        } else {\r\n            let added = false;\r\n            for (let i = 1; i <= this.collection.length; i++){\r\n                if (element.distance < this.collection[i-1].distance){\r\n                    this.collection.splice(i-1, 0, element);\r\n                    added = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!added){\r\n                this.collection.push(element);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    dequeue() {\r\n        return this.collection.shift();\r\n    };\r\n\r\n    isEmpty() {\r\n        return (this.collection.length === 0)\r\n    };\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// class Graph {\r\n//     // constructor() {\r\n//         // this.nodes = [];\r\n//         // this.neighboursList = {}; // list showing all neighbour nodes of a node\r\n//     // }\r\n//\r\n//     //\r\n//     //\r\n//     // addNode(node) {\r\n//     //     this.nodes.push(node);\r\n//     //     this.neighboursList[node] = [];\r\n//     // }\r\n//     //\r\n//     //\r\n//     // addEdge(node1, node2, weight) {\r\n//     //     this.neighboursList[node1].push({node:node2, weight: weight});\r\n//     //     this.neighboursList[node2].push({node:node1, weight: weight});\r\n//     // }\r\n//     //\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//     // findPathWithDijkstra(startNode, endNode){\r\n//     //     let times = {};\r\n//     //     let backtrace = {};\r\n//     //     let pq = new PriorityQueue();\r\n//     //\r\n//     //     times[startNode] = 0;\r\n//     //\r\n//     //     // console.log({...times});\r\n//     //\r\n//     //\r\n//     //     this.nodes.forEach(node => {\r\n//     //         if (node !== startNode) {\r\n//     //             times[node] = Infinity\r\n//     //         }\r\n//     //     });\r\n//     //\r\n//     //     pq.enqueue([startNode, 0]);\r\n//     //\r\n//     //\r\n//     //\r\n//     //     while (!pq.isEmpty()) {\r\n//     //         let shortestStep = pq.dequeue();\r\n//     //         let currentNode = shortestStep[0];\r\n//     //         this.neighboursList[currentNode].forEach(neighbor => {\r\n//     //             let time = times[currentNode] + neighbor.weight;\r\n//     //             if (time < times[neighbor.node]) {\r\n//     //                 times[neighbor.node] = time;\r\n//     //                 backtrace[neighbor.node] = currentNode;\r\n//     //                 pq.enqueue([neighbor.node, time]);\r\n//     //             }\r\n//     //         });\r\n//     //     }\r\n//     //\r\n//     //     console.log({...backtrace});\r\n//     //\r\n//     //\r\n//     //\r\n//     //     let path = [endNode];\r\n//     //     let lastStep = endNode;\r\n//     //\r\n//     //     while(lastStep !== startNode) {\r\n//     //         path.unshift(backtrace[lastStep]);\r\n//     //         lastStep = backtrace[lastStep]\r\n//     //     }\r\n//     //\r\n//     //     return `Path is ${path} and time is ${times[endNode]}`;\r\n//     // }\r\n//\r\n//\r\n// }\r\n","//Took inspiration from:\r\n//https://en.wikipedia.org/wiki/Depth-first_search\r\n\r\n\r\nexport const findPathWithDepthFirst = (nodes,startNode, endNode,allowDiagonals)=>{\r\n\r\n    let allNodesVisitedByOrder=[];\r\n\r\n\r\n\r\n    for(let i=0;i<nodes.length;i++){\r\n        for(let j=0;j<nodes[i].length;j++){\r\n                nodes[i][j].isVisited=false;\r\n        }\r\n    }\r\n\r\n\r\n    let neighboursList;\r\n    let S = new Stack();\r\n\r\n    S.enqueue(startNode);\r\n\r\n    while (!S.isEmpty()){\r\n\r\n        let currentNode = S.dequeue();\r\n\r\n        if(currentNode.isWall){\r\n            continue;\r\n        }\r\n\r\n        if(!currentNode.isVisited){\r\n            currentNode.isVisited = true;\r\n\r\n            allNodesVisitedByOrder.push(currentNode);\r\n\r\n            neighboursList=getNeighboursNodes(currentNode,nodes,allowDiagonals);\r\n\r\n            neighboursList.forEach(neighbourNode=>{\r\n\r\n                    if(!neighbourNode.isVisited){\r\n                        // backTrack[neighbourNode['node']]=currentNode[0];\r\n                        nodes[neighbourNode.row][neighbourNode.col].prevRow=currentNode.row;\r\n                        nodes[neighbourNode.row][neighbourNode.col].prevCol=currentNode.col;\r\n                        S.enqueue(nodes[neighbourNode.row][neighbourNode.col]);\r\n                    }\r\n\r\n            });\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n        if(currentNode.row === endNode.row && currentNode.col === endNode.col ){\r\n            // console.log('breaking');\r\n            break;\r\n        }\r\n    }\r\n\r\n    allNodesVisitedByOrder.shift();\r\n    allNodesVisitedByOrder.pop();\r\n\r\n    // console.log(endNode)\r\n    // console.log(allNodesVisitedByOrder[allNodesVisitedByOrder.length-1]);\r\n    return {\r\n        visitedNodes:allNodesVisitedByOrder,\r\n        allNodes:nodes\r\n    };\r\n\r\n};\r\n\r\n\r\nconst getNeighboursNodes = (currentNode,nodes,allowDiagonals)=>{\r\n\r\n\r\n    let neighbours=[];\r\n\r\n    let lastRow=nodes[nodes.length-1];\r\n\r\n    //upper node\r\n    if(currentNode.row>0) {\r\n        neighbours.push(nodes[currentNode.row-1][currentNode.col]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n\r\n    }\r\n    //left node\r\n    if(currentNode.col>0){\r\n        neighbours.push(nodes[currentNode.row][currentNode.col-1]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n    }\r\n    //right node\r\n    if(currentNode.col < lastRow[lastRow.length-1].col){\r\n        neighbours.push(nodes[currentNode.row][currentNode.col+1]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n    }\r\n    // bottom node\r\n    if(currentNode.row < lastRow[0].row){\r\n        neighbours.push(nodes[currentNode.row+1][currentNode.col]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n    }\r\n\r\n\r\n    if(allowDiagonals){\r\n        // upper left node\r\n        if(currentNode.row>0 && currentNode.col>0){\r\n            neighbours.push(nodes[currentNode.row-1][currentNode.col-1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n        //upper right node\r\n        if(currentNode.row>0 && currentNode.col < lastRow[lastRow.length-1].col){\r\n\r\n            neighbours.push(nodes[currentNode.row-1][currentNode.col+1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n        // bottom left node\r\n        if(currentNode.row < lastRow[0].row && currentNode.col>0){\r\n            neighbours.push(nodes[currentNode.row+1][currentNode.col-1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n        // bottom right node\r\n        if(currentNode.row < lastRow[0].row && currentNode.col < lastRow[lastRow.length-1].col){\r\n            neighbours.push(nodes[currentNode.row+1][currentNode.col+1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n    }\r\n\r\n\r\n    return neighbours;\r\n\r\n\r\n};\r\n\r\n\r\nclass Stack {\r\n    constructor() {\r\n        this.collection = [];\r\n    }\r\n\r\n    enqueue(element){\r\n        this.collection.push(element);\r\n    };\r\n\r\n    dequeue() {\r\n        return this.collection.pop();\r\n    };\r\n\r\n    isEmpty() {\r\n        return (this.collection.length === 0)\r\n    };\r\n}\r\n\r\n\r\n","//Took inspiration from:\r\n//https://en.wikipedia.org/wiki/Best-first_search\r\n// https://www.javatpoint.com/ai-informed-search-algorithms#:~:text=Greedy%20best%2Dfirst%20search%20algorithm,the%20advantages%20of%20both%20algorithms.\r\n\r\nexport const findPathWithGreedyBFS = (nodes,startNode, endNode,allowDiagonals)=>{\r\n\r\n    let allNodesVisitedByOrder=[];\r\n\r\n    let loopNode;\r\n\r\n    //reset all nodes\r\n    for(let i=0;i<nodes.length;i++){\r\n\r\n        for(let j=0;j<nodes[i].length;j++){\r\n\r\n            loopNode=nodes[i][j];\r\n            loopNode.isVisited=false;\r\n            loopNode.f=0;\r\n            loopNode.h=0;\r\n            loopNode.closed=0;\r\n            loopNode.prevRow=null;\r\n            loopNode.prevCol=null;\r\n\r\n            if(!loopNode.isWall)\r\n                loopNode.weight = 1;\r\n            else\r\n                loopNode.weight = 0;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    let neighboursList;\r\n    let pq = new PriorityQueue();\r\n\r\n    startNode.h = heuristic(startNode,endNode); //get h cost\r\n\r\n    pq.enqueue(startNode);\r\n\r\n    while (!pq.isEmpty()){\r\n\r\n        let currentNode = pq.dequeue();\r\n\r\n        if(currentNode.row === endNode.row && currentNode.col === endNode.col ){\r\n            // console.log('breaking');\r\n            break;\r\n        }\r\n\r\n\r\n        if(currentNode.isWall){\r\n            continue;\r\n        }\r\n\r\n        currentNode.isVisited = true;\r\n\r\n        allNodesVisitedByOrder.push(currentNode);\r\n\r\n        neighboursList = getNeighboursNodes(currentNode,nodes,allowDiagonals);\r\n\r\n        neighboursList.forEach( neighbourNode =>{\r\n\r\n            if(! (neighbourNode.isWall || neighbourNode.closed) ) {\r\n\r\n\r\n                let beenVisited = neighbourNode.isVisited;\r\n\r\n                if (!beenVisited) {\r\n\r\n                    let neigh = nodes[neighbourNode.row][neighbourNode.col];\r\n\r\n                    neigh.isVisited = true;\r\n                    neigh.h = neighbourNode.h || heuristic(neighbourNode, endNode);\r\n                    neigh.f = neigh.h;\r\n\r\n                    // backTrack[neighbourNode['node']]=currentNode[0];\r\n                    neigh.prevRow = currentNode.row;\r\n                    neigh.prevCol = currentNode.col;\r\n\r\n                    if (!beenVisited)\r\n                        pq.enqueue(neigh);\r\n                    else\r\n                        pq.reorder(neigh);\r\n\r\n                }\r\n            }\r\n        });\r\n\r\n\r\n    }\r\n\r\n    //remove start node\r\n    allNodesVisitedByOrder.shift();\r\n\r\n    return {\r\n        visitedNodes:allNodesVisitedByOrder,\r\n        allNodes:nodes\r\n    };\r\n\r\n};\r\n\r\n\r\nconst getNeighboursNodes = (currentNode,nodes,allowDiagonals)=>{\r\n\r\n\r\n    let neighbours=[];\r\n\r\n    let lastRow=nodes[nodes.length-1];\r\n\r\n\r\n    //left node\r\n    if(currentNode.col>0){\r\n        neighbours.push(nodes[currentNode.row][currentNode.col-1]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n    }\r\n    //right node\r\n    if(currentNode.col < lastRow[lastRow.length-1].col){\r\n        neighbours.push(nodes[currentNode.row][currentNode.col+1]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n    }\r\n\r\n    //upper node\r\n    if(currentNode.row>0) {\r\n        neighbours.push(nodes[currentNode.row-1][currentNode.col]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n\r\n    }\r\n    // bottom node\r\n    if(currentNode.row < lastRow[0].row){\r\n        neighbours.push(nodes[currentNode.row+1][currentNode.col]);\r\n        neighbours[neighbours.length-1].weight=1;\r\n    }\r\n\r\n\r\n    if(allowDiagonals){\r\n        // upper left node\r\n        if(currentNode.row>0 && currentNode.col>0){\r\n            neighbours.push(nodes[currentNode.row-1][currentNode.col-1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n        //upper right node\r\n        if(currentNode.row>0 && currentNode.col < lastRow[lastRow.length-1].col){\r\n\r\n            neighbours.push(nodes[currentNode.row-1][currentNode.col+1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n        // bottom left node\r\n        if(currentNode.row < lastRow[0].row && currentNode.col>0){\r\n            neighbours.push(nodes[currentNode.row+1][currentNode.col-1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n        // bottom right node\r\n        if(currentNode.row < lastRow[0].row && currentNode.col < lastRow[lastRow.length-1].col){\r\n            neighbours.push(nodes[currentNode.row+1][currentNode.col+1]);\r\n            neighbours[neighbours.length-1].weight=1.5;\r\n        }\r\n    }\r\n\r\n\r\n    return neighbours;\r\n\r\n\r\n};\r\n\r\n\r\nclass PriorityQueue {\r\n    constructor() {\r\n        this.collection = [];\r\n    }\r\n\r\n    enqueue(element){\r\n        if (this.isEmpty()){\r\n            this.collection.push(element);\r\n        } else {\r\n            let added = false;\r\n            for (let i = 1; i <= this.collection.length; i++){\r\n                if (element.f < this.collection[i-1].f){\r\n                    this.collection.splice(i-1, 0, element);\r\n                    added = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!added){\r\n                this.collection.push(element);\r\n            }\r\n        }\r\n\r\n\r\n    };\r\n\r\n    reorder(element){\r\n\r\n\r\n        let eleIndex=this.collection.indexOf(element);\r\n\r\n        while (eleIndex>0){\r\n            let leftIndex=eleIndex-1;\r\n\r\n            if(eleIndex.f<this.collection[leftIndex].f){\r\n                let leftElement=this.collection[leftIndex];\r\n                this.collection[leftIndex]=element;\r\n                this.collection[eleIndex]=leftElement;\r\n\r\n                eleIndex=leftIndex;\r\n            }else\r\n                break;\r\n        }\r\n\r\n\r\n        // if (this.isEmpty()){\r\n        //     this.collection.push(element);\r\n        // } else {\r\n        //     let added = false;\r\n        //     for (let i = 1; i <= this.collection.length; i++){\r\n        //         if (element.f < this.collection[i-1].f){\r\n        //             this.collection.splice(i-1, 0, element);\r\n        //             added = true;\r\n        //             break;\r\n        //         }\r\n        //     }\r\n        //     if (!added){\r\n        //         this.collection.push(element);\r\n        //     }\r\n        // }\r\n    };\r\n\r\n    dequeue() {\r\n        return this.collection.shift();\r\n    };\r\n\r\n    isEmpty() {\r\n        return (this.collection.length === 0)\r\n    };\r\n}\r\n\r\n\r\nfunction heuristic(node,goal) {\r\n\r\n    // console.log(node.row,goal.x)\r\n    const dx = Math.abs(node.row - goal.row);\r\n    const dy = Math.abs(node.col - goal.col);\r\n\r\n    // console.log(dx,dy);\r\n\r\n    return dx + dy;\r\n}\r\n\r\n\r\n\r\n","//Took inspiration from:\r\n//http://weblog.jamisbuck.org/2011/1/12/maze-generation-recursive-division-algorithm\r\n\r\n\r\nconst HORIZONTAL=0;\r\nconst VERTICAL=1;\r\n\r\nexport const gridDivisionMazeGenerator= (nodes,startNode,endNode)=>{\r\n\r\n\r\n    //Supporting Variales\r\n\r\n    let wx,// X-cord from where to start creating wall\r\n        wy,// Y-cord from where to start creating wall\r\n        hx,// X-cord for Hole to be created in wall\r\n        hy,// Y-cord for Hole to be created in wall\r\n        box1,// there would be two new boxes when we create a wall in a box\r\n        box2;\r\n\r\n    // let allNodesVisitedByOrder=[];\r\n\r\n    //Reset all nodes\r\n    for(let i=0;i<nodes.length;i++){\r\n        for(let j=0;j<nodes[i].length;j++){\r\n\r\n            nodes[i][j].isWall=false;\r\n            nodes[i][j].isShortest=false;\r\n            nodes[i][j].visited=false;\r\n            nodes[i][j].prevRow=null;\r\n            nodes[i][j].prevCol=null;\r\n            nodes[i][j].isVisited=false;\r\n\r\n        }\r\n    }\r\n\r\n    nodes[startNode.row][startNode.col].isWall=false;\r\n    nodes[endNode.row][endNode.col].isWall=false;\r\n\r\n    //Stack to keep all new boxes\r\n    let S = new Stack();\r\n\r\n    //Initial box\r\n    let box={\r\n        x:0,\r\n        y:0,\r\n        maxX:nodes[0].length-1,\r\n        maxY:nodes.length-1,\r\n        width:nodes[0].length-1,\r\n        height:nodes.length-1,\r\n        orientation:choose_orientation(nodes[0].length-1,nodes.length-1)\r\n    };\r\n\r\n    S.enqueue(box);\r\n\r\n\r\n    while (!S.isEmpty()){\r\n\r\n        let currentBox = S.dequeue();\r\n\r\n        if(currentBox.width < 2 || currentBox.height < 2) continue;\r\n\r\n\r\n        //from where the wall will start\r\n        wx= currentBox.orientation ? Math.floor(randomNumber(currentBox.x, currentBox.maxX)/2)*2 : currentBox.x;\r\n        wy= currentBox.orientation ? currentBox.y : Math.floor(randomNumber(currentBox.y, currentBox.maxY)/2)*2;\r\n\r\n        //where the hole would be in the wall\r\n        hx = wx + (currentBox.orientation ? 0 :  Math.floor(Math.random()*currentBox.width));\r\n        hy = wy + (currentBox.orientation ? Math.floor(Math.random()*currentBox.height) : 0);\r\n\r\n\r\n        //making new Wall in the currentBox and getting 2 new Boxes\r\n\r\n        if(currentBox.orientation){//wall would be created vertically\r\n\r\n            //===========check and clear if passsage/hole doesn't gets block by a new wall=============\r\n\r\n            let changed=false;\r\n\r\n            if(wy>0){\r\n                //if there is a passage right above the wall the make hole right at starting of the wall\r\n                if(!nodes[wy-1][wx].isWall){\r\n                    hy = wy;\r\n                    changed=true;\r\n                }\r\n            }\r\n\r\n            if(currentBox.maxY+1<nodes.length){\r\n                //if there is a passage right below the wall the make hole at end of the wall and\r\n                if(!nodes[currentBox.maxY + 1][wx].isWall){\r\n                    hy = currentBox.maxY;\r\n                    if(changed)wy++; //top most node of the wall would also be left empety\r\n                }\r\n            }\r\n            //=====================================================================================\r\n\r\n\r\n\r\n            //new boxes that would be created after a Wall would be constructed in the current box\r\n\r\n            box1={\r\n                x:currentBox.x,\r\n                y:currentBox.y,\r\n                maxX:wx-1,\r\n                maxY:currentBox.maxY,\r\n                width:wx-currentBox.x,\r\n                height:currentBox.height,\r\n                orientation:choose_orientation( wx-currentBox.x ,currentBox.height)\r\n            };\r\n\r\n            box2={\r\n                x : wx + 1,\r\n                y : wy,\r\n                maxX:currentBox.maxX,\r\n                maxY:currentBox.maxY,\r\n                width : currentBox.maxX - Math.max(wx,1),\r\n                height : currentBox.height,\r\n                orientation : choose_orientation( (currentBox.x+currentBox.width) - wx  , currentBox.height )\r\n            };\r\n\r\n            //creating wall\r\n            while (wy <= currentBox.maxY) {\r\n                if(wy !== hy &&  !(wy === startNode.row && wx===startNode.col) && !(wy === endNode.row && wx===endNode.col) ){\r\n                    nodes[wy][wx].isWall=true;\r\n                    // allNodesVisitedByOrder.push(nodes[wy][wx]);\r\n                }\r\n                wy++;\r\n            }\r\n\r\n        }\r\n        else {//wall would be created horizontally\r\n\r\n            //=========check and clear if passsage gets block by a new wall=========\r\n\r\n            let changed=false;\r\n            if(wx > 0 ) {\r\n                if (!nodes[wy][wx - 1].isWall){ //if there is a passage at left side of the horizontal wall\r\n                    hx = wx;//make a hole a starting of the wall\r\n                    changed=true;\r\n                }\r\n            }\r\n\r\n            if(currentBox.maxX < nodes[0].length){ // if current box length is smaller than the total width of the grid\r\n                if (nodes[wy][currentBox.maxX + 1]){ // if there is a node after the max width of the current box\r\n\r\n                    if (!nodes[wy][currentBox.maxX + 1].isWall){ //if there is a passage at the end (right side)of the horizontal wall\r\n\r\n                        // check if really there is a wall and the wall has a passage\r\n                        //to confirm there is a wall at right side, there should be a Wall Node at top or bottom of the selected node\r\n                        if(nodes[wy+1]){\r\n                            if(nodes[wy+1][currentBox.maxX+1].isWall){\r\n                                hx = currentBox.maxX ;\r\n                                if(changed){\r\n                                    wx++;\r\n                                }\r\n                            }\r\n                        }else if(nodes[wy-1]){\r\n                            if(nodes[wy-1][currentBox.maxX+1].isWall){\r\n                                hx = currentBox.maxX;\r\n                                if(changed){\r\n                                    wx++;\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                    }\r\n\r\n\r\n\r\n                }\r\n            }\r\n\r\n            //================================================================================\r\n\r\n            //new boxes that would be created after a Wall would be constructed in the current box\r\n\r\n            box1={\r\n                x:currentBox.x,\r\n                y:currentBox.y,\r\n                maxX:currentBox.maxX,\r\n                maxY:wy-1,\r\n                width:currentBox.width,\r\n                height:wy-currentBox.y,\r\n                orientation:choose_orientation(currentBox.width,currentBox.height-wy)\r\n            };\r\n\r\n            box2={\r\n                x : wx,\r\n                y : wy+1,\r\n                maxX:currentBox.maxX,\r\n                maxY:currentBox.maxY,\r\n                width : currentBox.width,\r\n                height : currentBox.maxY-wy,\r\n                orientation : choose_orientation( currentBox.width , (currentBox.height+currentBox.y)-wy )\r\n            };\r\n\r\n            while (wx <= currentBox.maxX) {\r\n                if(wx !== hx && !(wy === startNode.row && wx===startNode.col) && !(wy === endNode.row && wx===endNode.col)){\r\n                    nodes[wy][wx].isWall=true;\r\n                    // allNodesVisitedByOrder.push(nodes[wy][wx]);\r\n                }\r\n                wx++;\r\n            }\r\n        }\r\n\r\n\r\n        S.enqueue(box1);\r\n        S.enqueue(box2);\r\n\r\n    }\r\n\r\n    return {\r\n        // visitedNodes:allNodesVisitedByOrder,\r\n        allNodes:nodes\r\n    };\r\n\r\n};\r\n\r\n\r\nclass Stack {\r\n    constructor() {\r\n        this.collection = [];\r\n    }\r\n\r\n    enqueue(element){\r\n        this.collection.push(element);\r\n    };\r\n\r\n    dequeue() {\r\n        return this.collection.pop();\r\n    };\r\n\r\n    isEmpty() {\r\n        return (this.collection.length === 0)\r\n    };\r\n}\r\n\r\n\r\nconst choose_orientation = (width,height)=>{\r\n\r\n    if(height>width)\r\n        return HORIZONTAL;\r\n    else if (height<width)\r\n        return VERTICAL;\r\n    else\r\n        return (Math.random()>0.5 ? HORIZONTAL : VERTICAL);\r\n\r\n\r\n\r\n};\r\n\r\n\r\n//Does not include min and max\r\nfunction randomNumber(min, max) {\r\n    min++;\r\n    max--;\r\n    return Math.round(Math.random() * (max - min) + min);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//\r\n// export const mazeGeneratorDFS= (grid, x, y, width, height, orientation)=> {\r\n//     if(width <= 4 || height <= 4 ) return;\r\n//\r\n//     let horizontal = orientation === HORIZONTAL;\r\n//\r\n//     let wx = x + (horizontal ? 0 : Math.floor(Math.random()*(width-2))),\r\n//         wy = y + (horizontal ? Math.floor(Math.random()*(height-2)) : 0);\r\n//\r\n//     let px = wx + (horizontal ? Math.floor(Math.random()*(width)) : 0),\r\n//         py = wy + (horizontal ? 0 : Math.floor(Math.random()*(height)));\r\n//\r\n//     let dx = horizontal ? 1 : 0,\r\n//         dy = horizontal ? 0 : 1,\r\n//         length = horizontal ? width : height;\r\n//\r\n//     for(let i=0;i<length;i++){\r\n//\r\n//         console.log(wx);\r\n//         if(wx!==px || wy!==py)\r\n//             grid[wy][wx].isWall=true;\r\n//\r\n//         wx += dx;\r\n//         wy += dy;\r\n//     }\r\n//\r\n//     let nx = x,\r\n//         ny = y,\r\n//         w = horizontal ? width : wx-x+1,\r\n//         h = horizontal ?  wy-y+1 : height;\r\n//\r\n//     mazeGeneratorDFS(grid, nx, ny, w, h, choose_orientation(w, h));\r\n//\r\n//     nx = horizontal ? x: wx+1;\r\n//     ny = horizontal ? wy+1 : y;\r\n//     w = horizontal ? width: x+width-wx-1;\r\n//     h = horizontal ? y+height-wy-1 : height;\r\n//     mazeGeneratorDFS(grid, nx, ny, w, h, choose_orientation(w, h))\r\n//\r\n// };","import {cloneNodes} from '../Visualizer';\r\n\r\nconst generateRandomWalls=(grid,startNode,endNode)=>{\r\n\r\n    let nodesClone = cloneNodes(grid),\r\n        nodeObj;\r\n\r\n    for (let i=0;i<nodesClone.length;i++){\r\n\r\n        for (let j=0;j<nodesClone[i].length;j++) {\r\n\r\n            nodeObj = {...nodesClone[i][j]};\r\n\r\n            if( (nodeObj.row === startNode.row && nodeObj.col === startNode.col)\r\n                || (nodeObj.row === endNode.row && nodeObj.col === endNode.col)){\r\n                nodesClone[i][j]=nodeObj;\r\n                continue;\r\n            }\r\n\r\n\r\n            nodeObj[\"isWall\"]=false;\r\n\r\n            nodeObj[\"isWall\"] = Math.random() > 0.63;\r\n\r\n            nodeObj['isShortest']=false;\r\n            nodeObj['visited']=false;\r\n\r\n            nodesClone[i][j]=nodeObj;\r\n        }\r\n\r\n    }\r\n\r\n    return nodesClone;\r\n\r\n};\r\n\r\n\r\nexport default generateRandomWalls;","import React from 'react';\r\n\r\n\r\nconst Backdrop=(props)=>{\r\n\r\n    let className='backdrop';\r\n\r\n    if(!props.show)\r\n        className+=' hide';\r\n\r\n    return(\r\n        <div className={className} onClick={props.clicked}/>\r\n    )\r\n\r\n};\r\n\r\n\r\nexport default Backdrop;","import React from 'react';\r\nimport Backdrop from './Backdrop';\r\n\r\nconst About =(props)=>{\r\n    let className='aboutContent';\r\n\r\n    if(!props.show)\r\n        className+=' hideAbout';\r\n\r\n    return(\r\n        <>\r\n            <Backdrop show={props.show} clicked={props.toggle}/>\r\n            <div className={className}>\r\n                <div className=\"close\" onClick={props.toggle}/>\r\n                <div className=\"nodeDescription\">\r\n                    <div className=\"node start\"/>\r\n                    <p>Start Node</p>\r\n                </div>\r\n                <div className=\"nodeDescription\">\r\n                    <div className=\"node end\"/>\r\n                    <p>End Node</p>\r\n                </div>\r\n                <div className=\"nodeDescription\">\r\n                    <div className=\"node wall\"/>\r\n                    <p>Wall Node</p>\r\n                </div>\r\n                <div className=\"nodeDescription\">\r\n                    <div className=\"node visit\"/>\r\n                    <p>Visited Node</p>\r\n                </div>\r\n                <div className=\"nodeDescription\">\r\n                    <div className=\"node short\"/>\r\n                    <p>Shortest Path Node</p>\r\n                </div>\r\n\r\n\r\n                <div className=\"instructions\">\r\n                    <h3>Instructions:</h3>\r\n                    <p>\r\n                        Click on Start/End Node to select it. After selecting the node, move your mouse on Grid to rearrange the Node\r\n                    </p>\r\n\r\n                    <p>\r\n                        Click on White/Empty Box and start moving your mouse on Grid to make a Wall. To stop creating the wall, Click again on the Grid.\r\n                    </p>\r\n\r\n                    <p>\r\n                        Chose Algorithm, from top-left Dropdown, which you want to play with.\r\n                    </p>\r\n\r\n                    <p>\r\n                        If you want to add a Maze or random Walls in the Grid, you can select it from \"Generate\" Dropdown.\r\n                    </p>\r\n\r\n                    <p>\r\n                        Click \"Start\" Button to start the Visualizer and see the magic.\r\n                    </p>\r\n\r\n                    <p>\r\n                        You can change Speed of Visualizer from \"Speed\" Dropdown preset at top-right side.\r\n                    </p>\r\n\r\n                    <p>\r\n                        Play with different Algorithms and have fun...\r\n                    </p>\r\n\r\n                </div>\r\n            </div>\r\n\r\n        </>\r\n    )\r\n\r\n};\r\n\r\nexport default About;","import React from 'react';\r\nimport Node from '../../components/Node/Node'\r\nimport {findPathWithDijkstra} from '../Visualizer/algorithms/dijkstra';\r\nimport {findPathWithAStar} from '../Visualizer/algorithms/astar';\r\nimport {findPathWithBreathFirst} from './algorithms/breathFirst';\r\nimport {findPathWithDepthFirst} from './algorithms/depthFirst';\r\nimport {findPathWithGreedyBFS} from './algorithms/greedyBFS';\r\nimport {gridDivisionMazeGenerator} from './mazeGenerator/gridDivisionMazeGenerator';\r\nimport generateRandomWalls from './mazeGenerator/randomWalls';\r\nimport About from '../../components/About/About'\r\nimport img from '../../img/about.png';\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst  startNodeRow = Math.floor(window.innerHeight/60)-2;\r\nconst  startNodeCol = Math.floor(Math.floor(window.innerWidth/28)/5);\r\nconst  endNodeRow = Math.floor(window.innerHeight/60)-2;\r\nconst  endNodeCol = Math.floor(Math.floor(window.innerWidth/28)/1.2);\r\n\r\nconst aniTimer=100;\r\n\r\nclass Visualizer extends React.Component{\r\n\r\n    constructor(props){\r\n        super(props);\r\n\r\n\r\n        this.state={\r\n            nodes:[],\r\n            isMousePressed:false,\r\n            currentAlgo:'Dijkstra',\r\n            generateMaze:'select',\r\n            algoSpeed:1,\r\n            allowDiagonal:false,\r\n            startNodeRow:0,\r\n            startNodeCol:0,\r\n            endNodeRow:0,\r\n            endNodeCol:0,\r\n            startNodeSelected:false,\r\n            endNodeSelected:false,\r\n            isVisualized:false,\r\n            isRunning:false,\r\n            showAbout:false\r\n        };\r\n\r\n        this.visitedNodesTimeout=undefined;\r\n        this.shortestnodeTimeout=undefined;\r\n    }\r\n\r\n\r\n    componentDidMount() {\r\n\r\n\r\n\r\n        document.addEventListener('keydown',this.startAlgo);\r\n        let nodes=[],\r\n            column=[],\r\n            totalRows=Math.floor(window.innerHeight/28)-2,\r\n            totalCols=Math.floor(window.innerWidth/28);\r\n\r\n\r\n        for(let i=0;i<totalRows;i++){\r\n            column=[];\r\n            for(let j=0;j<totalCols;j++){\r\n                column.push({\r\n                    row:i,\r\n                    col:j,\r\n                    isWall:false,\r\n                    visited:false,\r\n                    animateDelay:0,\r\n                    isShortest:false,\r\n                    animation:true\r\n\r\n                })\r\n            }\r\n            nodes.push(column);\r\n        }\r\n\r\n\r\n\r\n        this.setState({\r\n            nodes:nodes,\r\n            startNodeRow,\r\n            startNodeCol,\r\n            endNodeRow,\r\n            endNodeCol,\r\n\r\n        })\r\n    }\r\n\r\n    nodeClicked=(row,col)=>{\r\n\r\n        if(this.state.isRunning) return;\r\n\r\n\r\n        //unselect node\r\n        if(this.state.isMousePressed){\r\n            this.setState({\r\n                isMousePressed:false,\r\n                startNodeSelected:false,\r\n                endNodeSelected:false\r\n            });\r\n            return;\r\n        }\r\n\r\n        if((row === this.state.startNodeRow && col === this.state.startNodeCol)){ //select start node\r\n\r\n            this.setState({\r\n                startNodeSelected:true,\r\n                endNodeSelected:false,\r\n                isMousePressed:true\r\n            });\r\n            return;\r\n\r\n        }else if(( row === this.state.endNodeRow && col === this.state.endNodeCol )){//select end node\r\n\r\n            this.setState({\r\n                startNodeSelected:false,\r\n                endNodeSelected:true,\r\n                isMousePressed:true\r\n            });\r\n            return;\r\n        }\r\n\r\n\r\n\r\n        const nodes=this.getNewGridWithWalls(this.state.nodes,row,col);\r\n\r\n        this.setState(prevState => {\r\n            return {\r\n                    nodes:nodes,\r\n                    isMousePressed:!prevState.isMousePressed,\r\n                    startNodeSelected:false,\r\n                    endNodeSelected:false,\r\n            }\r\n        });\r\n\r\n    };\r\n\r\n    mouseEnter=(row,col)=>{\r\n\r\n\r\n        if(!this.state.isMousePressed || this.state.isRunning) return;\r\n\r\n        //if mouse enter in start or end node\r\n        if((row === this.state.startNodeRow && col === this.state.startNodeCol)\r\n            || (row === this.state.endNodeRow && col === this.state.endNodeCol))\r\n            return;\r\n\r\n\r\n\r\n\r\n\r\n        if(this.state.startNodeSelected){\r\n            if(this.state.nodes[row][col].isWall) return;\r\n\r\n            this.setState({\r\n                startNodeRow:row,\r\n                startNodeCol:col\r\n            });\r\n\r\n            if(this.state.isVisualized)\r\n                this.restructureVisualizer(row,col,true,false);\r\n\r\n\r\n        }else if (this.state.endNodeSelected) {\r\n            if(this.state.nodes[row][col].isWall) return;\r\n\r\n            this.setState({\r\n                endNodeRow:row,\r\n                endNodeCol:col\r\n            });\r\n\r\n            if(this.state.isVisualized)\r\n                this.restructureVisualizer(row,col,false,true);\r\n\r\n        }else {// if start/end node are not selected then create a new wall at the node where mous entered\r\n\r\n            const nodes=this.getNewGridWithWalls(this.state.nodes,row,col);\r\n            this.setState({nodes:nodes});\r\n\r\n        }\r\n    };\r\n\r\n    restructureVisualizer=(row,col,isStartSelected=false,isEndSelected=false)=>{\r\n\r\n        this.startAlgo({},false,isStartSelected,isEndSelected);\r\n\r\n\r\n    };\r\n\r\n\r\n    startAlgo=(e,addAnimation=true,isStartSelected=false,isEndSelected=false)=>{\r\n\r\n        if(e.type=== 'keydown' && e.keyCode!==13)\r\n            return;\r\n\r\n\r\n        if(e.type === 'click')\r\n            e.target.blur();\r\n\r\n\r\n        //clear all nodes befor starting visualization\r\n        let resetNodes = this.resetNodes();\r\n        this.setState({nodes:resetNodes});\r\n\r\n        window.setTimeout(()=>{\r\n            const currentAlgo=this.state.currentAlgo;\r\n            const allowDiagonal=this.state.allowDiagonal;\r\n\r\n            const nodes=this.state.nodes;\r\n            const startNode=nodes[this.state.startNodeRow][this.state.startNodeCol];\r\n            const endNode=nodes[this.state.endNodeRow][this.state.endNodeCol];\r\n\r\n            let result;\r\n            if(currentAlgo.indexOf('Dijkstra')>-1){\r\n                    result=findPathWithDijkstra(nodes,startNode,endNode,allowDiagonal);\r\n            }\r\n            else if(currentAlgo.indexOf('AStar')>-1){\r\n                result= findPathWithAStar(nodes,startNode,endNode,allowDiagonal);\r\n            }\r\n            else if(currentAlgo.indexOf('breathFirst')>-1){\r\n                result = findPathWithBreathFirst(nodes,startNode,endNode,allowDiagonal);\r\n            }\r\n            else if(currentAlgo.indexOf('depthFirst') > -1){\r\n                result = findPathWithDepthFirst(nodes,startNode,endNode,allowDiagonal);\r\n            }\r\n            else if(currentAlgo.indexOf('greedyBestFirst') > -1){\r\n                result = findPathWithGreedyBFS(nodes,startNode,endNode,allowDiagonal);\r\n            }\r\n\r\n            this.startVisualizer(result,addAnimation,isStartSelected,isEndSelected);\r\n\r\n        },0);\r\n\r\n\r\n    };\r\n\r\n\r\n    startVisualizer=(result,addAnimation=true,isStartSelected=false,isEndSelected=false)=>{\r\n\r\n        let nodes=[...this.state.nodes],\r\n            allNodes = result.allNodes,\r\n            visitedNodes = result.visitedNodes;\r\n\r\n        const startNode=nodes[this.state.startNodeRow][this.state.startNodeCol];\r\n        const endNode=nodes[this.state.endNodeRow][this.state.endNodeCol];\r\n        \r\n\r\n\r\n        //Set all nodes that are visited and change the state\r\n        for(let i=0;i<visitedNodes.length;i++){\r\n            nodes[visitedNodes[i].row][visitedNodes[i].col].visited=true;\r\n\r\n            if(addAnimation)\r\n                nodes[visitedNodes[i].row][visitedNodes[i].col].animateDelay=((i+1)/aniTimer)/this.state.algoSpeed;\r\n            else\r\n                nodes[visitedNodes[i].row][visitedNodes[i].col].animation=false;\r\n\r\n        }\r\n\r\n        //This state change is for visited nodes and their animation\r\n        this.setState({\r\n            nodes:nodes,\r\n            isRunning:true\r\n        });\r\n\r\n\r\n\r\n\r\n        let timeoutForShortestPath = 0;\r\n        if(addAnimation)\r\n            timeoutForShortestPath = Number((visitedNodes.length/aniTimer)/this.state.algoSpeed)*1000;\r\n\r\n\r\n        //Timeout will run when all visited nodes are animated and it adds shortest path nodes in the grid\r\n        this.visitedNodesTimeout = window.setTimeout(()=>{\r\n\r\n\r\n            let backTrack=[endNode]; // backtrach array will have shortest path nodes in a sequence\r\n            let lastStep=endNode,\r\n                animationCounter=0.01,\r\n                animationIncrement = animationCounter/this.state.algoSpeed; // Animation delay time counter for shortest nodes\r\n\r\n            while(lastStep !== startNode){\r\n                //Finding and setting up shortest path nodes & add them in backtrack array\r\n\r\n                let currentNodeRow,\r\n                    currentNodeCol,\r\n                    stepBackNode;\r\n\r\n                try{\r\n                    currentNodeRow = backTrack[0].row;\r\n                    currentNodeCol = backTrack[0].col;\r\n\r\n                    stepBackNode = allNodes\r\n                        [allNodes[currentNodeRow][currentNodeCol].prevRow]\r\n                        [allNodes[currentNodeRow][currentNodeCol].prevCol];\r\n\r\n                }catch (e) {\r\n                    // alert(\"Can't find shortest path.\");\r\n                    break;\r\n                }\r\n\r\n                backTrack.unshift(stepBackNode);\r\n                lastStep=stepBackNode;\r\n\r\n\r\n                if(backTrack[0] !== endNode)\r\n                    nodes[currentNodeRow][currentNodeCol].isShortest=true;\r\n\r\n            }\r\n\r\n            nodes[endNode.row][endNode.col].isShortest=false;\r\n\r\n            if(addAnimation){\r\n                //adding animation delay for shortest nodes\r\n                for(let node of backTrack){\r\n                    if(!node) continue;\r\n                    nodes[node.row][node.col].animateDelay = animationCounter;\r\n                    animationCounter += animationIncrement;\r\n                }\r\n            }\r\n\r\n\r\n\r\n            //setting state nodes with shortest nodes\r\n            this.setState({\r\n                nodes:nodes\r\n            });\r\n\r\n            let shortestnodeTimeoutDelay=0;\r\n            if(addAnimation)\r\n                shortestnodeTimeoutDelay=Number((backTrack.length*animationIncrement)*1000);\r\n\r\n            //timeout will run after shortest path animation is finished and reset timeouts and state\r\n            this.shortestnodeTimeout=window.setTimeout(()=>{\r\n\r\n\r\n                const nodeWitoutDelay=this.removeAniDelayFromNodes();\r\n\r\n                this.setState({\r\n                    nodes:nodeWitoutDelay,\r\n                    isRunning:false,\r\n                    startNodeSelected:isStartSelected,\r\n                    endNodeSelected:isEndSelected,\r\n                    isMousePressed:(isStartSelected || isEndSelected),\r\n                    isVisualized:true\r\n                });\r\n\r\n                clearTimeout(this.visitedNodesTimeout);\r\n                clearTimeout(this.shortestnodeTimeout);\r\n\r\n\r\n\r\n\r\n            },shortestnodeTimeoutDelay);\r\n\r\n        },timeoutForShortestPath);\r\n\r\n    };\r\n\r\n\r\n    getNewGridWithWalls=(grid,row,col)=>{\r\n\r\n        const nodes=grid.slice();\r\n\r\n        const node=nodes[row][col];\r\n\r\n\r\n        nodes[row][col]={\r\n            ...node,\r\n            isWall: !node.isWall,\r\n            visited:false,\r\n            isShortest:false\r\n        };\r\n\r\n        return nodes;\r\n    };\r\n\r\n    resetNodes=()=>{\r\n\r\n        let nodesClone=cloneNodes(this.state.nodes);\r\n\r\n        for (let i=0;i<nodesClone.length;i++){\r\n            for (let j=0;j<nodesClone[i].length;j++) {\r\n\r\n                // nodesClone[i][j][\"isWall\"]=false;\r\n                nodesClone[i][j]['isShortest']=false;\r\n                nodesClone[i][j]['visited']=false;\r\n                nodesClone[i][j]['prevRow']=null;\r\n                nodesClone[i][j]['prevCol']=null;\r\n                nodesClone[i][j]['animateDelay']=0;\r\n                nodesClone[i][j]['animation']=true;\r\n            }\r\n        }\r\n\r\n        clearTimeout(this.visitedNodesTimeout);\r\n        clearTimeout(this.shortestnodeTimeout);\r\n\r\n        this.setState({isVisualized:false});\r\n        return nodesClone;\r\n    };\r\n\r\n    removeAniDelayFromNodes=()=>{\r\n        let nodesClone = cloneNodes(this.state.nodes);\r\n\r\n        for (let i=0;i<nodesClone.length;i++){\r\n            for (let j=0;j<nodesClone[i].length;j++) {\r\n                nodesClone[i][j]['animateDelay']=0;\r\n            }\r\n        }\r\n\r\n        return nodesClone;\r\n    };\r\n\r\n    resetVisualizer=()=>{\r\n\r\n        let nodesClone = cloneNodes(this.state.nodes);\r\n\r\n        for (let i=0;i<nodesClone.length;i++){\r\n\r\n            for (let j=0;j<nodesClone[i].length;j++) {\r\n\r\n\r\n                nodesClone[i][j][\"isWall\"]=false;\r\n                nodesClone[i][j]['isShortest']=false;\r\n                nodesClone[i][j]['visited']=false;\r\n                nodesClone[i][j]['prevRow']=null;\r\n                nodesClone[i][j]['prevCol']=null;\r\n                nodesClone[i][j]['animateDelay']=0;\r\n                nodesClone[i][j]['animation']=true;\r\n\r\n            }\r\n        }\r\n\r\n\r\n        clearTimeout(this.visitedNodesTimeout);\r\n        clearTimeout(this.shortestnodeTimeout);\r\n\r\n\r\n        this.setState({\r\n            nodes:nodesClone,\r\n            isRunning:false,\r\n            isVisualized:false,\r\n            currentAlgo:'Dijkstra',\r\n            generateMaze:'select',\r\n            algoSpeed:1,\r\n            allowDiagonal:false,\r\n            startNodeRow,\r\n            startNodeCol,\r\n            endNodeRow,\r\n            endNodeCol,\r\n        });\r\n\r\n    };\r\n\r\n    resetWalls=()=>{\r\n\r\n        if(this.state.isRunning)\r\n            return;\r\n\r\n        let nodesClone = cloneNodes(this.state.nodes);\r\n\r\n        for (let i=0;i<nodesClone.length;i++){\r\n            for (let j=0;j<nodesClone[i].length;j++) {\r\n                nodesClone[i][j][\"isWall\"]=false;\r\n            }\r\n        }\r\n\r\n        this.setState({\r\n            nodes:nodesClone,\r\n            generateMaze:'select'\r\n\r\n        });\r\n\r\n    };\r\n\r\n    resetPath=()=>{\r\n\r\n        if(this.state.isRunning)\r\n            return;\r\n\r\n        let nodesClone = cloneNodes(this.state.nodes);\r\n\r\n        for (let i=0;i<nodesClone.length;i++){\r\n            for (let j=0;j<nodesClone[i].length;j++) {\r\n\r\n                nodesClone[i][j]['isShortest']=false;\r\n                nodesClone[i][j]['visited']=false;\r\n                nodesClone[i][j]['prevRow']=null;\r\n                nodesClone[i][j]['prevCol']=null;\r\n                nodesClone[i][j]['animateDelay']=0;\r\n                nodesClone[i][j]['animation']=true;\r\n\r\n            }\r\n        }\r\n\r\n\r\n\r\n        this.setState({\r\n            nodes:nodesClone,\r\n            isVisualized:false\r\n        });\r\n\r\n    };\r\n\r\n\r\n    algoSetup=(e)=>{\r\n        this.setState({\r\n            currentAlgo:e.target.value,\r\n        })\r\n    };\r\n\r\n    speedChangeHandler=(e)=>{\r\n        this.setState({\r\n            algoSpeed:e.target.value,\r\n        })\r\n    };\r\n\r\n    diagonalChangeHandler=(e)=>{\r\n\r\n        this.setState(prevState => {\r\n            return{\r\n                allowDiagonal:!prevState.allowDiagonal\r\n            }\r\n        })\r\n    };\r\n\r\n    mazeChangeHandler=(e)=>{\r\n        if(this.state.isRunning) return;\r\n\r\n        this.setState({\r\n            generateMaze:e.target.value,\r\n        });\r\n\r\n        let nodesGrid=this.state.nodes;\r\n        const startNode=nodesGrid[this.state.startNodeRow][this.state.startNodeCol];\r\n        const endNode=nodesGrid[this.state.endNodeRow][this.state.endNodeCol];\r\n\r\n        if(e.target.value==='walls'){\r\n\r\n            let randomWalls=generateRandomWalls(nodesGrid,startNode,endNode);\r\n\r\n            this.setState({\r\n                nodes:randomWalls,\r\n            });\r\n\r\n        }\r\n        else if(e.target.value==='simple'){\r\n\r\n\r\n            let nodesClone = cloneNodes(nodesGrid);\r\n\r\n            let result=gridDivisionMazeGenerator(nodesClone,startNode,endNode);\r\n\r\n            this.setState({\r\n                nodes:result.allNodes\r\n            })\r\n\r\n\r\n        }\r\n\r\n    };\r\n\r\n\r\n    toggleAbout=()=>{\r\n\r\n        console.log('clicked');\r\n        this.setState(prevState => {\r\n            return{\r\n                showAbout:!prevState.showAbout\r\n            }\r\n        })\r\n\r\n    };\r\n\r\n\r\n    render(){\r\n\r\n        return(\r\n            <>\r\n                <div className='visualizerHeader'>\r\n                    <label htmlFor=\"algoDropdown\">Algorithm:\r\n                        <select name=\"algoDropdown\" id=\"algoDropdown\" value={this.state.currentAlgo} onChange={this.algoSetup}>\r\n                            <option value=\"Dijkstra\">Dijkstra Algoritm</option>\r\n                            <option value=\"AStar\">A* Algoritm</option>\r\n                            <option value=\"breathFirst\">Breath First</option>\r\n                            <option value=\"depthFirst\">Depth First</option>\r\n                            <option value=\"greedyBestFirst\">GBF Search</option>\r\n                        </select>\r\n                    </label>\r\n\r\n                    <label htmlFor=\"generateMaze\" >Generate:\r\n                        <select name=\"generateMaze\"\r\n                                disabled={this.state.isRunning}\r\n                                id=\"generateMaze\"\r\n                                value={this.state.generateMaze}\r\n                                onChange={this.mazeChangeHandler}>\r\n\r\n                            <option value=\"select\">Select Pattern</option>\r\n                            <option value=\"walls\">Random Walls</option>\r\n                            <option value=\"simple\">Simple Maze</option>\r\n                        </select>\r\n                    </label>\r\n\r\n                    <button onClick={this.startAlgo}>Start</button>\r\n                    <button onClick={this.resetVisualizer}>Reset Visualizer</button>\r\n                    <button onClick={this.resetWalls} disabled={(this.state.isRunning)}>Reset Walls</button>\r\n                    <button onClick={this.resetPath} disabled={(this.state.isRunning)}>Reset Path</button>\r\n\r\n\r\n                    <label htmlFor=\"allowDiagonal\">\r\n                        Allow Diagonal:\r\n                        <input type=\"checkbox\"\r\n                               id='allowDiagonal'\r\n                               checked={this.state.allowDiagonal}\r\n                               onChange={this.diagonalChangeHandler}/>\r\n                    </label>\r\n\r\n                    <label htmlFor=\"algoSpeed\">Speed:\r\n                        <select name=\"algoSpeed\"\r\n                                id=\"algoSpeed\"\r\n                                value={this.state.algoSpeed}\r\n                                onChange={this.speedChangeHandler}>\r\n                            <option value=\"0.0625\">0.0625x</option>\r\n                            <option value=\"0.125\">0.125x</option>\r\n                            <option value=\"0.25\">0.25x</option>\r\n                            <option value=\"0.5\">0.5x</option>\r\n                            <option value=\"0.75\">0.75x</option>\r\n                            <option value=\"1\">1x</option>\r\n                            <option value=\"1.5 \">1.5x</option>\r\n                            <option value=\"1.75\">1.75x</option>\r\n                            <option value=\"2\">2x</option>\r\n                            <option value=\"4\">4x</option>\r\n                        </select>\r\n                    </label>\r\n\r\n                    <img src={img} alt=\"about\" onClick={this.toggleAbout}/>\r\n                </div>\r\n\r\n                <div className='visualizer'>\r\n                    {this.state.nodes.map(colum=>{\r\n\r\n                        return colum.map(node=>{\r\n                            return <Node\r\n                                    class='node'\r\n                                    row={node.row}\r\n                                    col={node.col}\r\n                                    isStartNode={node.row === this.state.startNodeRow && node.col === this.state.startNodeCol}\r\n                                    isEndNode={node.row === this.state.endNodeRow && node.col === this.state.endNodeCol}\r\n                                    isStartNodeSelected={this.state.startNodeSelected}\r\n                                    isEndNodeSelected={this.state.endNodeSelected}\r\n                                    isWall={node.isWall}\r\n                                    isVisited={node.visited}\r\n                                    isShortest={node.isShortest}\r\n                                    animation={node.animation}\r\n                                    delay={node.animateDelay}\r\n                                    clicked={this.nodeClicked}\r\n                                    mouseEnter={this.mouseEnter}\r\n                                    // mouseUp={this.mouseUp}\r\n                                    key={node.row+' '+ node.col}/>\r\n\r\n                        })\r\n\r\n                    })\r\n                    }\r\n                </div>\r\n\r\n                <About show={this.state.showAbout} toggle={this.toggleAbout}/>\r\n            </>\r\n        )\r\n\r\n    }\r\n    \r\n    \r\n}\r\n\r\nexport const cloneNodes=(grid)=>{\r\n    let nodesClone=[];\r\n\r\n    let nodesStateClone=[...grid];\r\n\r\n    let nodeObj,rowClone;\r\n\r\n    for (let i=0;i<nodesStateClone.length;i++){\r\n        nodesClone[i]=[];\r\n        rowClone=nodesStateClone[i];\r\n        for (let j=0;j<nodesStateClone[i].length;j++) {\r\n            nodesClone[i][j]={...rowClone[j]};\r\n        }\r\n    }\r\n\r\n    return nodesClone;\r\n};\r\n\r\n\r\nexport default Visualizer;","import React from 'react';\nimport Visualizer from './containers/Visualizer/Visualizer'\nimport './App.css';\n\nfunction App() {\n  return (\n    <Visualizer/>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}